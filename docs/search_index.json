[["index.html", "R Programming Notes for Data Science Chapter 1 Acknowledgement", " R Programming Notes for Data Science dea 2021-12-30 Chapter 1 Acknowledgement I have been compiling notes and tips on R programming from everywhere. Most of these notes coming from Data Science Specialization Course from Courseara. "],["r-programming.html", "Chapter 2 R Programming 2.1 General Information", " Chapter 2 R Programming R is a functional programming language. It is most popular among academia and Data Sciencetists. 2.1 General Information Cleaning the environment rm(list = ls()) Installing a package install.packages(&quot;ggplot2&quot;) # install detach(ggplot2, unload = TRUE) # removing the library Browsing help on packages browseVignettes(&quot;ggplot2&quot;) wd &lt;- getwd() wd ## [1] &quot;/Users/d842a922/Desktop/R/_my_R_book&quot; # listing environment objects ls() ## [1] &quot;wd&quot; # listing files in the working directory files &lt;- list.files() head(files) ## [1] &quot;_book&quot; &quot;_bookdown_files&quot; &quot;_bookdown.yml&quot; &quot;_build.sh&quot; ## [5] &quot;_deploy.sh&quot; &quot;_my_R_book&quot; # listing files in the working directory files2 &lt;- dir() head(files2) ## [1] &quot;_book&quot; &quot;_bookdown_files&quot; &quot;_bookdown.yml&quot; &quot;_build.sh&quot; ## [5] &quot;_deploy.sh&quot; &quot;_my_R_book&quot; dir( pattern = &quot;^L&quot;, full.names = F, ignore.case = T ) old.dir &lt;- getwd() # creating a folder in the directory dir.create(&quot;testdir&quot;) setwd(&quot;testdir&quot;) #create a file file.create(&quot;testdir/mytest.R&quot;) file.exists(&quot;testdir/mytest.R&quot;) file.info(&quot;testdir/mytest.R&quot;) # to list files in path myfiles &lt;- list.files(path=&quot;testdir&quot;, pattern = &quot;[2]&quot;) head(myfiles) #rename filename from to file.rename(&quot;testdir/mytest.R&quot;, &quot;testdir/mytest4.R&quot;) list.files(path=&quot;testdir&quot;, pattern = &quot;[4]&quot;) # interactive file1 &lt;- file.choose() # copy file from to file.copy(&quot;testdir/mytest2.R&quot;, &quot;testdir/mytest3.R&quot;) myfiles class(myfiles) # character vector myfiles[1] setwd(&quot;testdir&quot;) file.copy(myfiles[1], &quot;deneme2.xlsx&quot;) # assign a name to a file path (exist or not) path1 &lt;- file.path(&quot;mytest3.R&quot;) path1 directory creation: testdir/deneme3 dir.create(file.path(&quot;testdir&quot;, &quot;deneme3&quot;), recursive = TRUE ) # assign a name to a folder path (olmak zorunda degiller) abc &lt;- file.path(&quot;testdir&quot;, &quot;deneme&quot;) abc double colon There may be multiple functions with the same name in multiple packages. The double colon operator allows you to specify the specific function you want: dplyr::filter() str(file.path) args((file.path)) # then you can use variable names directly attach(mtcars) "],["create-sequence-of-numbers.html", "Chapter 3 Create sequence of numbers", " Chapter 3 Create sequence of numbers a &lt;- seq(from = 5, to = 14, by = 2) a ## [1] 5 7 9 11 13 # generates integer sequence of length(along.with) seq(along.with = 1:12) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 seq_along(1:15) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 seq(length.out = 4) ## [1] 1 2 3 4 seq_len(10) ## [1] 1 2 3 4 5 6 7 8 9 10 a = seq(10, 20) b = seq(10, 30, by =2) 3.0.1 – %in% This creates a logical vector, where testing each element in vector “a” if ever matches any element in vector “b” c &lt;- a %in% b c ## [1] TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE 3.0.2 which() which(x, arr.ind = FALSE, useNames = TRUE) input a logical vector returns location index of true values which(c) ## [1] 1 3 5 7 9 11 d &lt;- LETTERS[1:10] d ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; e &lt;- LETTERS[5:10] e ## [1] &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; d %in% e ## [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE which(d %in% e) ## location of TRUE values of vector d (matches vector e) ## [1] 5 6 7 8 9 10 g &lt;- c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;) h &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;) i &lt;- g %in% h i ## [1] TRUE TRUE TRUE FALSE FALSE FALSE which(g == h) ## integer(0) # subsetting property g[g %in% h] ## [1] &quot;c&quot; &quot;d&quot; &quot;e&quot; which( (1:12) %% 2 == 0, arr.ind = F) ## location in the array (1:12) ## [1] 2 4 6 8 10 12 3.0.3 Where is the min, max, first true/false? which.min() which.max() a = c(2, 4, 1, 7, 9, 1, 3, 5, 9, NA, &quot;4&quot;) a ## [1] &quot;2&quot; &quot;4&quot; &quot;1&quot; &quot;7&quot; &quot;9&quot; &quot;1&quot; &quot;3&quot; &quot;5&quot; &quot;9&quot; NA &quot;4&quot; which.min(a &gt; 4) ## [1] 1 which.max(a) ## [1] 5 a[which.max(a)] ## [1] &quot;9&quot; match(a, b) match: An integer vector giving the position in table of the first match if there is a match, otherwise nomatch. min(which(x == a)) a = 1:15 b = seq(1, 20, by=3) match(a, b) ## returns location of true values of vector a ## [1] 1 NA NA 2 NA NA 3 NA NA 4 NA NA 5 NA NA a %in% b ## [1] TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE TRUE FALSE FALSE ## [13] TRUE FALSE FALSE dataframe df &lt;- cars head(df) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 ## 5 8 16 ## 6 9 10 # test if value 5 in speed column 5 %in% df$speed ## [1] FALSE # create a dataframe df2 &lt;- data.frame(Type = c(&quot;fruit&quot;, &quot;fruit&quot;,&quot;fruit&quot;, &quot;veggie&quot;,&quot;veggie&quot;), Name = c(&quot;red apple&quot;, &quot;green apple&quot;, &quot;red apple&quot;, &quot;green apple&quot; ,&quot;red apple&quot;), Color = c(NA, &quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;red&quot;)) df2 ## Type Name Color ## 1 fruit red apple &lt;NA&gt; ## 2 fruit green apple red ## 3 fruit red apple blue ## 4 veggie green apple yellow ## 5 veggie red apple red df2 &lt;- within(df2, { newcol = &quot;No&quot; newcol[Type %in% c(&quot;fruit&quot;)] = &quot;No&quot; newcol[Name %in% c( &quot;green apple&quot;)] = &quot;Yes&quot; }) head(df2, 3) ## Type Name Color newcol ## 1 fruit red apple &lt;NA&gt; No ## 2 fruit green apple red Yes ## 3 fruit red apple blue No subsetting library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union df3 &lt;- c(&quot;home&quot;, &quot;veggie&quot;, &quot;fruit&quot;) df2 %&gt;% filter(df2$Type %in% df3) ## Type Name Color newcol ## 1 fruit red apple &lt;NA&gt; No ## 2 fruit green apple red Yes ## 3 fruit red apple blue No ## 4 veggie green apple yellow Yes ## 5 veggie red apple red &lt;NA&gt; dropping columns df2[, !(colnames(df2) %in% c(&quot;Name&quot;, &quot;Color&quot;)) ] ## Type newcol ## 1 fruit No ## 2 fruit Yes ## 3 fruit No ## 4 veggie Yes ## 5 veggie &lt;NA&gt; selecting columns df2[, (colnames(df2) %in% c(&quot;Name&quot;, &quot;Color&quot;)) ] ## Name Color ## 1 red apple &lt;NA&gt; ## 2 green apple red ## 3 red apple blue ## 4 green apple yellow ## 5 red apple red creating custom operator `%notin%` &lt;- Negate(`%in%`) numbs &lt;- rep(seq(3), 4) numbs ## [1] 1 2 3 1 2 3 1 2 3 1 2 3 4 %notin% numbs ## [1] TRUE "],["logic-statements.html", "Chapter 4 Logic statements", " Chapter 4 Logic statements TRUE vs FALSE TRUE == TRUE ## [1] TRUE (FALSE == TRUE) == FALSE ## [1] TRUE 6==7 ## [1] FALSE 6&lt;=6 ## [1] TRUE 4 != 5 ## [1] TRUE !(5 == 71) ## [1] TRUE TRUE &amp; TRUE ## [1] TRUE FALSE &amp; FALSE ## [1] FALSE TRUE &amp; c(TRUE, FALSE, FALSE) ## [1] TRUE FALSE FALSE equivalent statement as c(TRUE, TRUE, TRUE) &amp; c(TRUE, FALSE, FALSE) ## [1] TRUE FALSE FALSE "],["be-careful.html", "Chapter 5 be careful", " Chapter 5 be careful TRUE &amp;&amp; c(TRUE, FALSE, FALSE) ## [1] TRUE In this case, the left operand is only evaluated with the first member of the right operand (the vector). The rest of the elements in the vector aren’t evaluated at all in this expression. TRUE | FALSE ## [1] TRUE TRUE | c(TRUE, FALSE, FALSE) ## [1] TRUE TRUE TRUE TRUE || c(TRUE, FALSE, FALSE) ## [1] TRUE FALSE &amp;&amp; 6 &gt;= 6 || 7 &gt;= 8 || 50 &lt;= 49.5 ## [1] FALSE !(8 &gt; 4) || 5 == 5.0 &amp;&amp; 7.8 &gt;= 7.79 ## [1] TRUE TRUE &amp;&amp; FALSE || 9 &gt;= 4 &amp;&amp; 3 &lt; 6 ## [1] TRUE 99.99 &gt; 100 || 45 &lt; 7.3 || 4 != 4.0 ## [1] FALSE isTRUE(6&gt;4) ## [1] TRUE identical(&#39;twins&#39;, &#39;twins&#39;) ## [1] TRUE The xor() function stands for exclusive OR. If one argument evaluates to TRUE and one argument evaluates to FALSE, then this function will return TRUE, otherwise it will return FALSE. xor(5 == 6, !FALSE) ## [1] TRUE xor(T, T) ## [1] FALSE xor(F, F) ## [1] FALSE xor(identical(xor, &#39;xor&#39;), 7 == 7.0) ## [1] TRUE xor(4 &gt;= 9, 8 != 8.0) ## [1] FALSE ints &lt;- sample(10) ints &gt; 5 ## [1] TRUE TRUE TRUE FALSE FALSE FALSE TRUE TRUE FALSE FALSE The which() function takes a logical vector as an argument and returns the indices of the vector that are TRUE. which(c(TRUE, FALSE, TRUE)) ## [1] 1 3 x &lt;- ints&gt;7 which(x) ## [1] 1 2 8 The any() function will return TRUE if one or more of the elements in the logical vector is TRUE. any(ints&lt;0) ## [1] FALSE The all() function will return TRUE if every element in the logical vector is TRUE. all(ints&gt;0) ## [1] TRUE any(ints == 10) ## [1] TRUE all(c(TRUE, FALSE, TRUE)) ## [1] FALSE "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
